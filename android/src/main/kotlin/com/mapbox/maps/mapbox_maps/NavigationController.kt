package com.mapbox.maps.mapbox_maps

import android.annotation.SuppressLint
import android.content.Context
import android.content.res.Resources
import android.os.Bundle
import androidx.lifecycle.Lifecycle
import androidx.lifecycle.LifecycleOwner
import com.mapbox.api.directions.v5.models.RouteOptions
import com.mapbox.bindgen.Expected
import com.mapbox.common.location.Location
import com.mapbox.geojson.Point
import com.mapbox.maps.EdgeInsets
import com.mapbox.maps.MapView
import com.mapbox.maps.mapbox_maps.navigation.NavigationInterface
import com.mapbox.maps.plugin.animation.camera
import com.mapbox.maps.plugin.locationcomponent.LocationComponentPlugin
import com.mapbox.maps.plugin.locationcomponent.OnIndicatorPositionChangedListener
import com.mapbox.maps.plugin.locationcomponent.location
import com.mapbox.navigation.base.ExperimentalPreviewMapboxNavigationAPI
import com.mapbox.navigation.base.TimeFormat
import com.mapbox.navigation.base.extensions.applyDefaultNavigationOptions
import com.mapbox.navigation.base.extensions.applyLanguageAndVoiceUnitOptions
import com.mapbox.navigation.base.formatter.DistanceFormatterOptions
import com.mapbox.navigation.base.options.NavigationOptions
import com.mapbox.navigation.base.route.NavigationRoute
import com.mapbox.navigation.base.route.NavigationRouterCallback
import com.mapbox.navigation.base.route.RouteAlternativesOptions
import com.mapbox.navigation.base.route.RouterFailure
import com.mapbox.navigation.base.route.RouterOrigin
import com.mapbox.navigation.core.MapboxNavigation
import com.mapbox.navigation.core.MapboxNavigationProvider
import com.mapbox.navigation.core.directions.session.RoutesObserver
import com.mapbox.navigation.core.formatter.MapboxDistanceFormatter
import com.mapbox.navigation.core.lifecycle.MapboxNavigationApp
import com.mapbox.navigation.core.replay.route.ReplayProgressObserver
import com.mapbox.navigation.core.replay.route.ReplayRouteMapper
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.core.trip.session.RouteProgressObserver
import com.mapbox.navigation.core.trip.session.VoiceInstructionsObserver
import com.mapbox.navigation.tripdata.maneuver.api.MapboxManeuverApi
import com.mapbox.navigation.tripdata.progress.api.MapboxTripProgressApi
import com.mapbox.navigation.tripdata.progress.model.DistanceRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.EstimatedTimeOfArrivalFormatter
import com.mapbox.navigation.tripdata.progress.model.PercentDistanceTraveledFormatter
import com.mapbox.navigation.tripdata.progress.model.TimeRemainingFormatter
import com.mapbox.navigation.tripdata.progress.model.TripProgressUpdateFormatter
import com.mapbox.navigation.ui.base.util.MapboxNavigationConsumer
import com.mapbox.navigation.ui.maps.NavigationStyles
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowApi
import com.mapbox.navigation.ui.maps.route.arrow.api.MapboxRouteArrowView
import com.mapbox.navigation.ui.maps.route.arrow.model.RouteArrowOptions
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineApi
import com.mapbox.navigation.ui.maps.route.line.api.MapboxRouteLineView
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineApiOptions
import com.mapbox.navigation.ui.maps.route.line.model.MapboxRouteLineViewOptions
import com.mapbox.navigation.voice.api.MapboxSpeechApi
import com.mapbox.navigation.voice.api.MapboxVoiceInstructionsPlayer
import com.mapbox.navigation.voice.model.SpeechAnnouncement
import com.mapbox.navigation.voice.model.SpeechError
import com.mapbox.navigation.voice.model.SpeechValue
import com.mapbox.navigation.voice.model.SpeechVolume
import io.flutter.Log
import io.flutter.plugin.common.BasicMessageChannel
import io.flutter.plugin.common.BinaryMessenger
import io.flutter.plugin.common.MessageCodec
import java.util.Locale
import kotlin.time.Duration.Companion.seconds

@SuppressLint("VisibleForTests")
@OptIn(ExperimentalPreviewMapboxNavigationAPI::class)
class NavigationController(
  private val context: Context,
  private val mapView: MapView,
  override val lifecycle: Lifecycle
) : NavigationInterface, LifecycleOwner {

  private lateinit var locationComponent: LocationComponentPlugin

  /**
   * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
   * to the Maps SDK in order to update the user location indicator on the map.
   */
  private val navigationLocationProvider = NavigationLocationProvider()

  /**
   * Generates updates for the [MapboxManeuverView] to display the upcoming maneuver instructions
   * and remaining distance to the maneuver point.
   */
  private lateinit var maneuverApi: MapboxManeuverApi

  /**
   * Generates updates for the [MapboxTripProgressView] that include remaining time and distance to the destination.
   */
  private lateinit var tripProgressApi: MapboxTripProgressApi

  /**
   * Generates updates for the [routeLineView] with the geometries and properties of the routes that should be drawn on the map.
   */
  private lateinit var routeLineApi: MapboxRouteLineApi

  /**
   * Draws route lines on the map based on the data from the [routeLineApi]
   */
  private lateinit var routeLineView: MapboxRouteLineView

  /**
   * Generates updates for the [routeArrowView] with the geometries and properties of maneuver arrows that should be drawn on the map.
   */
  private val routeArrowApi: MapboxRouteArrowApi = MapboxRouteArrowApi()

  /**
   * Draws maneuver arrows on the map based on the data [routeArrowApi].
   */
  private lateinit var routeArrowView: MapboxRouteArrowView

  /**
   * Used to execute camera transitions based on the data generated by the [viewportDataSource].
   * This includes transitions from route overview to route following and continuously updating the camera as the location changes.
   */
  private lateinit var navigationCamera: NavigationCamera

  /**
   * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
   */
  private lateinit var viewportDataSource: MapboxNavigationViewportDataSource

  /**
   * Debug observer that makes sure the replayer has always an up-to-date information to generate mock updates.
   */
  private lateinit var replayProgressObserver: ReplayProgressObserver

  /**
   * Debug object that converts a route into events that can be replayed to navigate a route.
   */
  private val replayRouteMapper = ReplayRouteMapper()

  /**
   * Stores and updates the state of whether the voice instructions should be played as they come or muted.
   */
  private var isVoiceInstructionsMuted = false
    set(value) {
      field = value
      if (value) {
        voiceInstructionsPlayer.volume(SpeechVolume(0f))
      } else {
        voiceInstructionsPlayer.volume(SpeechVolume(1f))
      }
    }

  /**
   * Extracts message that should be communicated to the driver about the upcoming maneuver.
   * When possible, downloads a synthesized audio file that can be played back to the driver.
   */
  private lateinit var speechApi: MapboxSpeechApi

  /**
   * Plays the synthesized audio files with upcoming maneuver instructions
   * or uses an on-device Text-To-Speech engine to communicate the message to the driver.
   * NOTE: do not use lazy initialization for this class since it takes some time to initialize
   * the system services required for on-device speech synthesis. With lazy initialization
   * there is a high risk that said services will not be available when the first instruction
   * has to be played. [MapboxVoiceInstructionsPlayer] should be instantiated in
   * `Activity#onCreate`.
   */
  private lateinit var voiceInstructionsPlayer: MapboxVoiceInstructionsPlayer

  /**
   * Observes when a new voice instruction should be played.
   */
  private val voiceInstructionsObserver = VoiceInstructionsObserver { voiceInstructions ->
    speechApi.generate(voiceInstructions, speechCallback)
  }

  /**
   * Below are generated camera padding values to ensure that the route fits well on screen while
   * other elements are overlaid on top of the map (including instruction view, buttons, etc.)
   */
  private val pixelDensity = Resources.getSystem().displayMetrics.density

  private val overviewPadding: EdgeInsets by lazy {
    EdgeInsets(
      140.0 * pixelDensity,
      40.0 * pixelDensity,
      120.0 * pixelDensity,
      40.0 * pixelDensity
    )
  }

  private val landscapeOverviewPadding: EdgeInsets by lazy {
    EdgeInsets(
      30.0 * pixelDensity,
      380.0 * pixelDensity,
      110.0 * pixelDensity,
      20.0 * pixelDensity
    )
  }

  private val followingPadding: EdgeInsets by lazy {
    EdgeInsets(
      180.0 * pixelDensity,
      40.0 * pixelDensity,
      150.0 * pixelDensity,
      40.0 * pixelDensity
    )
  }

  private val landscapeFollowingPadding: EdgeInsets by lazy {
    EdgeInsets(
      30.0 * pixelDensity,
      380.0 * pixelDensity,
      110.0 * pixelDensity,
      40.0 * pixelDensity
    )
  }

  private lateinit var mapboxNavigation: MapboxNavigation

  /**
   * Gets notified with location updates.
   *
   * Exposes raw updates coming directly from the location services
   * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
   */
  private val locationObserver = object : LocationObserver {
    var firstLocationUpdateReceived = false

    override fun onNewRawLocation(rawLocation: Location) {
      // not handled
    }

    override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
      val enhancedLocation = locationMatcherResult.enhancedLocation
      // update location puck's position on the map
      navigationLocationProvider.changePosition(
        location = enhancedLocation,
        keyPoints = locationMatcherResult.keyPoints,
      )

      // update camera position to account for new location
      viewportDataSource.onLocationChanged(enhancedLocation)
      viewportDataSource.evaluate()

      // if this is the first location update the activity has received,
      // it's best to immediately move the camera to the current user location
      if (!firstLocationUpdateReceived) {
        firstLocationUpdateReceived = true
        navigationCamera.requestNavigationCameraToOverview(
          stateTransitionOptions = NavigationCameraTransitionOptions.Builder()
            .maxDuration(0) // instant transition
            .build()
        )
      } else {
        navigationCamera.requestNavigationCameraToFollowing()
      }
    }
  }

  /**
   * Gets notified with progress along the currently active route.
   */
  private val routeProgressObserver = RouteProgressObserver { routeProgress ->
    // update the camera position to account for the progressed fragment of the route
    viewportDataSource.onRouteProgressChanged(routeProgress)
    viewportDataSource.evaluate()


    // update top banner with maneuver instructions
    val maneuvers = maneuverApi.getManeuvers(routeProgress)
  }

  /**
   * Gets notified whenever the tracked routes change.
   *
   * A change can mean:
   * - routes get changed with [MapboxNavigation.setNavigationRoutes]
   * - routes annotations get refreshed (for example, congestion annotation that indicate the live traffic along the route)
   * - driver got off route and a reroute was executed
   */
  private val routesObserver = RoutesObserver { routeUpdateResult ->
    if (routeUpdateResult.navigationRoutes.isNotEmpty()) {
      // generate route geometries asynchronously and render them
      routeLineApi.setNavigationRoutes(
        routeUpdateResult.navigationRoutes
      ) { value ->
        mapView.mapboxMap.style?.apply {
          routeLineView.renderRouteDrawData(this, value)
        }
      }

      // update the camera position to account for the new route
      viewportDataSource.onRouteChanged(routeUpdateResult.navigationRoutes.first())
      viewportDataSource.evaluate()
    } else {
      // remove the route line and route arrow from the map
      val style = mapView.mapboxMap.style
      if (style != null) {
        routeLineApi.clearRouteLine { value ->
          routeLineView.renderClearRouteLineValue(
            style,
            value
          )
        }
        routeArrowView.render(style, routeArrowApi.clearArrows())
      }

      // remove the route reference from camera position evaluations
      viewportDataSource.clearRouteData()
      viewportDataSource.evaluate()
    }
  }

  /**
   * Based on whether the synthesized audio file is available, the callback plays the file
   * or uses the fall back which is played back using the on-device Text-To-Speech engine.
   */
  private val speechCallback =
    MapboxNavigationConsumer<Expected<SpeechError, SpeechValue>> { expected ->
      expected.fold(
        { error ->
          // play the instruction via fallback text-to-speech engine
          voiceInstructionsPlayer.play(
            error.fallback,
            voiceInstructionsPlayerCallback
          )
        },
        { value ->
          // play the sound file from the external generator
          voiceInstructionsPlayer.play(
            value.announcement,
            voiceInstructionsPlayerCallback
          )
        }
      )
    }

  /**
   * When a synthesized audio file was downloaded, this callback cleans up the disk after it was played.
   */
  private val voiceInstructionsPlayerCallback =
    MapboxNavigationConsumer<SpeechAnnouncement> { value ->
      // remove already consumed file to free-up space
      speechApi.clean(value)
    }

  /**
   * RouteLine: This listener is necessary only when enabling the vanishing route line feature
   * which changes the color of the route line behind the puck during navigation. If this
   * option is set to `false` (the default) in MapboxRouteLineApiOptions then it is not necessary
   * to use this listener.
   */
  private val onPositionChangedListener = OnIndicatorPositionChangedListener { point ->
    val result = routeLineApi.updateTraveledRouteLine(point)
    mapView.mapboxMap.style?.apply {
      // Render the result to update the map.
      routeLineView.renderRouteLineUpdate(this, result)
    }
  }

  /**
   *
   */
  init {
    val mapboxMap = mapView.mapboxMap
    var camera = mapView.camera

    viewportDataSource = MapboxNavigationViewportDataSource(mapboxMap)
    navigationCamera = NavigationCamera(mapboxMap, camera, viewportDataSource)

    val distanceFormatterOptions = DistanceFormatterOptions.Builder(context).build()
    maneuverApi = MapboxManeuverApi(
      MapboxDistanceFormatter(distanceFormatterOptions)
    )

    tripProgressApi = MapboxTripProgressApi(
      TripProgressUpdateFormatter.Builder(context)
        .distanceRemainingFormatter(
          DistanceRemainingFormatter(distanceFormatterOptions)
        )
        .timeRemainingFormatter(
          TimeRemainingFormatter(context)
        )
        .percentRouteTraveledFormatter(
          PercentDistanceTraveledFormatter()
        )
        .estimatedTimeOfArrivalFormatter(
          EstimatedTimeOfArrivalFormatter(context, TimeFormat.TWENTY_FOUR_HOURS)
        )
        .build()
    )

    speechApi = MapboxSpeechApi(
      context,
      Locale.US.language
    )

    voiceInstructionsPlayer = MapboxVoiceInstructionsPlayer(
      context,
      Locale.US.language
    )

    // initialize route line, the routeLineBelowLayerId is specified to place
    // the route line below road labels layer on the map
    // the value of this option will depend on the style that you are using
    // and under which layer the route line should be placed on the map layers stack
    val mapboxRouteLineViewOptions = MapboxRouteLineViewOptions.Builder(context)
      .routeLineBelowLayerId("road-label-navigation")
      .build()

    routeLineApi = MapboxRouteLineApi(MapboxRouteLineApiOptions.Builder().build())
    routeLineView = MapboxRouteLineView(mapboxRouteLineViewOptions)

    // initialize maneuver arrow view to draw arrows on the map
    val routeArrowOptions = RouteArrowOptions.Builder(context).build()
    routeArrowView = MapboxRouteArrowView(routeArrowOptions)

    MapboxNavigationApp.setup(
      NavigationOptions.Builder(context)
        .routeAlternativesOptions(
          RouteAlternativesOptions.Builder()
            .intervalMillis(30.seconds.inWholeMilliseconds)
            .build()
        )
        .build()
    )

    MapboxNavigationApp.attach(this)
    mapboxNavigation = MapboxNavigationApp.current()!!

    mapboxNavigation.registerRoutesObserver(routesObserver)
    mapboxNavigation.registerLocationObserver(locationObserver)
    mapboxNavigation.registerRouteProgressObserver(routeProgressObserver)
    mapboxNavigation.registerVoiceInstructionsObserver(voiceInstructionsObserver)

    replayProgressObserver = ReplayProgressObserver(mapboxNavigation.mapboxReplayer)
    mapboxNavigation.registerRouteProgressObserver(replayProgressObserver)
  }

  private fun start() {
    locationComponent = mapView.location.apply {
      setLocationProvider(navigationLocationProvider)
      addOnIndicatorPositionChangedListener(onPositionChangedListener)
      enabled = true
    }

    viewportDataSource.options.followingFrameOptions.defaultPitch = 35.0
    viewportDataSource.evaluate()

    // Start the trip session to begin navigation
    mapboxNavigation.startTripSession()

    // Transition the camera to following mode
    navigationCamera.requestNavigationCameraToFollowing()
  }

  override fun setRoute(options: RouteOptions, callback: (Result<Unit>) -> Unit) {
    mapboxNavigation.requestRoutes(
      RouteOptions.builder()
        .applyDefaultNavigationOptions()
        .applyLanguageAndVoiceUnitOptions(context)
        .coordinatesList(options.coordinatesList())
        .alternatives(false)
        .layersList(listOf(mapboxNavigation.getZLevel(), null))
        .build(),
      object : NavigationRouterCallback {
        override fun onRoutesReady(
          routes: List<NavigationRoute>,
          @RouterOrigin routerOrigin: String
        ) {
          Log.d(LOG_TAG, "onSuccess: $routes")

          if (routes.isNotEmpty()) {
            // Set the routes to the routeLineApi
            routeLineApi.setNavigationRoutes(routes) { value ->
              // Render the route on the map using the routeLineView
              mapView.mapboxMap.style?.apply {
                routeLineView.renderRouteDrawData(this, value)
              }
            }

            // Set the routes for navigation
            mapboxNavigation.setNavigationRoutes(routes)

            start()
          }

          callback(Result.success(Unit))
        }

        override fun onFailure(
          reasons: List<RouterFailure>,
          routeOptions: RouteOptions
        ) {
          Log.d(LOG_TAG, "onFailure: $reasons")

          callback(Result.failure(Exception(reasons.toString())))
        }

        override fun onCanceled(
          routeOptions: RouteOptions,
          @RouterOrigin routerOrigin: String
        ) {
          Log.d(LOG_TAG, "onCanceled")

          callback(Result.failure(Exception("Navigation canceled")))
        }
      }
    )
  }

  fun dispose() {
    mapboxNavigation.unregisterRoutesObserver(routesObserver)
    mapboxNavigation.unregisterLocationObserver(locationObserver)
    mapboxNavigation.unregisterRouteProgressObserver(routeProgressObserver)
    mapboxNavigation.unregisterRouteProgressObserver(replayProgressObserver)
    mapboxNavigation.unregisterVoiceInstructionsObserver(voiceInstructionsObserver)
    mapboxNavigation.mapboxReplayer.finish()

    maneuverApi.cancel()
    routeLineApi.cancel()
    routeLineView.cancel()

    speechApi.cancel()
    voiceInstructionsPlayer.shutdown()

    locationComponent.removeOnIndicatorPositionChangedListener(onPositionChangedListener)
  }

  private companion object {
    val LOG_TAG: String = "MapboxNavigationController"
  }
}

